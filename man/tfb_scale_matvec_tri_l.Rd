% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bijectors.R
\name{tfb_scale_matvec_tri_l}
\alias{tfb_scale_matvec_tri_l}
\title{Compute \code{Y = g(X; scale) = scale @ X}.}
\usage{
tfb_scale_matvec_tri_l(scale_tril, adjoint = FALSE,
  validate_args = FALSE, name = "scale_matvec_tril", dtype = NULL)
}
\arguments{
\item{scale_tril}{Floating-point \code{Tensor} representing the lower triangular
matrix. \code{scale_tril} has shape \code{[N1, N2, ...  k, k]}, which represents a
k x k lower triangular matrix.
When \code{NULL} no \code{scale_tril} term is added to \code{scale}.
The upper triangular elements above the diagonal are ignored.}

\item{adjoint}{\code{logical} indicating whether to use the \code{scale} matrix as
specified or its adjoint. Note that lower-triangularity is taken into
account first: the region above the diagonal of \code{scale_tril} is treated
as zero (irrespective of the \code{adjoint} setting). A lower-triangular
input with \code{adjoint=TRUE} will behave like an upper triangular
transform. Default value: \code{FALSE}.}

\item{validate_args}{Logical, default FALSE. Whether to validate input with asserts. If validate_args is
FALSE, and the inputs are invalid, correct behavior is not guaranteed.}

\item{name}{name prefixed to Ops created by this class.}

\item{dtype}{\code{tf$DType} to prefer when converting args to \code{Tensor}s. Else, we
fall back to a common dtype inferred from the args, finally falling back
to float32.}
}
\value{
a bijector instance.
}
\description{
The \code{scale} term is presumed lower-triangular and non-singular (ie, no zeros
on the diagonal), which permits efficient determinant calculation (linear in
matrix dimension, instead of cubic).
}
