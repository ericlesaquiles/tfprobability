% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bijectors.R
\name{tfb_scale_matvec_diag}
\alias{tfb_scale_matvec_diag}
\title{Compute \code{Y = g(X; scale) = scale @ X}}
\usage{
tfb_scale_matvec_diag(scale_diag, adjoint = FALSE,
  validate_args = FALSE, name = "scale_matvec_diag", dtype = NULL)
}
\arguments{
\item{scale_diag}{Floating-point \code{Tensor} representing the diagonal matrix.
\code{scale_diag} has shape \code{[N1, N2, ...  k]}, which represents a k x k
diagonal matrix.}

\item{adjoint}{\code{logical} indicating whether to use the \code{scale} matrix as
specified or its adjoint. Default value: \code{FALSE}.}

\item{validate_args}{Logical, default FALSE. Whether to validate input with asserts. If validate_args is
FALSE, and the inputs are invalid, correct behavior is not guaranteed.}

\item{name}{name prefixed to Ops created by this class.}

\item{dtype}{\code{tf$DType} to prefer when converting args to \code{Tensor}s. Else, we
fall back to a common dtype inferred from the args, finally falling back
to \code{float32}.}
}
\value{
a bijector instance.
}
\description{
In TF parlance, the \code{scale} term is logically equivalent to:\preformatted{scale = tf$diag(scale_diag)
}

The \code{scale} term is applied without materializing a full dense matrix.
}
